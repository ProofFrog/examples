import 'examples/HPKE/KEM/DH.primitive';
import 'examples/HPKE/KEM/DDH.game';
import 'examples/HPKE/KEM/GDH.game';
import 'examples/HPKE/KDF/KDF.primitive';
import 'examples/HPKE/KDF/Security.game';
import 'examples/HPKE/KEM/OutsiderCCA.game';

Reduction R1(AKEM K) compose GDH(D) against OutsiderCCA(K).Adversary {
    K.PublicKey pk1;
    K.SecretKey sk1;
    
    K.PublicKey pk2;
    K.PublicKey pkE;

    Map<K.PublicKey * K.PublicKey * K.Ciphertext, K.SharedSecret> C; // [pkS, pkR, context] -> AKEM shared secret
    
    Map<BitString * BitString, K.SharedSecret> T; // KDF storage

    K.PublicKey * K.PublicKey Initialize() {
        // k1 is honestly generated
        K.SecretKey * K.PublicKey k1 = K.KeyGen();
        sk1 = k1[0];
        pk1 = k1[1];

        // pk2 and pkE are challenger-generated
        K.PublicKey * K.PublicKey k = challenger.Query();
        pk2 = k[0];
        pkE = k[1];

        return [pk1, pk2];
    }

    // Takes as input a sender index and receiver index
    // TODO: For now, assume i = 1, j = 2, and Chall is only called once
    K.Ciphertext? * K.SharedSecret? Chall(Int i, Int j) {
        if ((i != 1 && i != 2) || (j != 1 && j != 2)) { return [None, None]; }

        // K.AuthEncap(pk2, sk1)
        D.SharedSecret * D.SharedSecret dh = [D.GetSharedSecret(skE, pk2), D.GetSharedSecret(pk1, pk2)];
        Ciphertext enc = pkE;

        PublicKey pkS = D.GetPublicKey(pk1);
        PublicKey * PublicKey * PublicKey kemContext = [pkE, pk2, pkS];

        // SharedSecret k = ExtractAndExpand(dh, kemContext);
        BitString ikm = D.Encode(dh[0]) || D.Encode(dh[1]);
        BitString info = D.Encode(Nsecret) || D.Encode(kemContext[0]) || D.Encode(kemContext[1]) || D.Encode(kemContext[2]);
        K.SharedSecret k = KDF(ikm, info);

        // Store and return result
        C[[pk1, pk2, enc]] = k;
        return result;
    }

    K.Ciphertext? * K.SharedSecret? AEncap(Int i, K.PublicKey pkR) {
        if (i != 1 && i != 2) { return [None, None]; }
        K.Ciphertext * K.SharedSecret result = K.AuthEncap(pkR, sk[i-1]);
        return result;
    }

    K.SharedSecret? ADecap(Int j, K.PublicKey pkS, K.Ciphertext c) {
        if (j != 1 && j != 2) { return None; }
        if ([pkS, pk[j-1], c] in C) { return None; }
        K.SharedSecret result = K.AuthDecap(c, sk[j-1], pkS);
        return result;
    }

    // KDF is modelled as a random oracle
    K.SharedSecret KDF(BitString ikm, BitString info) {
        if (!([ikm, info] in T)) {
            T[[ikm, info]] <- K.SharedSecret;
        }
        return T[[ikm, info]];
    }
}

proof:

let:
    // Diffie-Hellman key exchange
    int g;
    int p;
    Set G;
    Set Z_q;
    DH D = DH(g, p, G, Z_q);

    // KDF
    int Nsecret; // length of shared secret generated by AuthDHKEM
    KDF F = KDF(Nsecret);

    // Authorized KEM
    DHAKEM K = DHAKEM(D, F, Nsecret);

assume:
    DDH(D);
    GDH(D);
    //Security(F); // F is a random oracle

theorem:
    OutsiderCCA(K);

games:
    OutsiderCCA(K).Left against OutsiderCCA(K).Adversary;

    OutsiderCCA(K).Right against OutsiderCCA(K).Adversary;

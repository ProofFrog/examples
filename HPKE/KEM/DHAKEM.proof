import 'examples/HPKE/KEM/DH.primitive';
import 'examples/HPKE/KEM/GDH.game';
import 'examples/HPKE/KDF/KDF.primitive';
import 'examples/HPKE/KEM/DHAKEM.scheme';
import 'examples/HPKE/KEM/OutsiderCCA.game';

Game Intermediate1(AKEM K, DH D, KDF F) {
    K.PublicKey * K.PublicKey pk;
    K.SecretKey * K.SecretKey sk;

    Map<K.PublicKey * K.PublicKey * K.Ciphertext, K.SharedSecret> C; // challenge
    
    Map<BitString * BitString, K.SharedSecret> L; // KDF storage

    K.PublicKey * K.PublicKey Initialize() {
        K.SecretKey * K.PublicKey k1 = D.KeyGen();
        K.SecretKey * K.PublicKey k2 = D.KeyGen();
        sk = [k1[0], k2[0]];
        pk = [k1[1], k2[1]];
        return pk;
    }

    // Takes as input a sender index and receiver index
    K.Ciphertext? * K.SharedSecret? Chall(Int i, Int j) {
        if ((i != 1 && i != 2) || (j != 1 && j != 2)) { return [None, None]; }

        // K.SharedSecret * K.Ciphertext result = K.AuthEncap(pk[j-1], sk[i-1]);
        K.PublicKey pkR = pk[j-1];
        K.SecretKey skS = sk[i-1];

        K.SecretKey * K.PublicKey ephemeralKey = D.KeyGen();
        K.SecretKey skE = ephemeralKey[0];
        K.PublicKey pkE = ephemeralKey[1];
        D.SharedSecret * D.SharedSecret dh = [D.GetSharedSecret(skE, pkR), D.GetSharedSecret(skS, pkR)];
        K.Ciphertext enc = pkE;

        K.PublicKey pkS = D.GetPublicKey(skS);
        K.PublicKey * K.PublicKey * K.PublicKey kemContext = [pkE, pkR, pkS];

        // SharedSecret k = ExtractAndExpand(dh, kemContext);
        BitString ikm = D.Encode(dh[0]) || D.Encode(dh[1]);
        BitString info = D.Encode(K.Nsecret) || D.Encode(kemContext[0]) || D.Encode(kemContext[1]) || D.Encode(kemContext[2]);
        K.SharedSecret k = F.evaluate(ikm, info);
        
        K.Ciphertext * K.SharedSecret result = [enc, k];
        // end of AuthEncap

        C[[pk[i-1], pk[j-1], result[0]]] = result[1];
        return result;
    }
}

proof:

let:
    // Diffie-Hellman
    Int g;
    Int p;
    Set G;
    Set Z_q;
    // Lengths for key serialization
    Int Npk;
    Int Nss;
    DH D = DH(g, p, G, Z_q, Npk, Nss);

    // KDF
    Int Nsecret; // length of shared secret generated by DHAKEM
    KDF F = KDF(Nsecret);

    // AKEM
    DHAKEM K = DHAKEM(D, F, Nsecret);

assume:
    GDH(D);

theorem:
    OutsiderCCA(K);

games:
    OutsiderCCA(K).Left against OutsiderCCA(K).Adversary;
    Intermediate1(K, D, F) against OutsiderCCA(K).Adversary;

    //GDH(D).Real compose R1(K, D) against OutsiderCCA(K).Adversary;
    //GDH(D).Random compose R1(K, D) against OutsiderCCA(K).Adversary;

    OutsiderCCA(K).Right against OutsiderCCA(K).Adversary;

import 'examples/HPKE/KEM/AKEM.primitive';

// Indistinguishability game for AKEM outsider CCA with two users.

Game Left(AKEM K) {
    K.PublicKey * K.PublicKey pk;
    K.SecretKey * K.SecretKey sk;

    Map<K.PublicKey * K.PublicKey * K.Ciphertext, K.SharedSecret> C; // [pkS, pkR, context] -> AKEM shared secret
    
    Map<BitString * BitString, K.SharedSecret> T; // KDF storage

    K.PublicKey * K.PublicKey Initialize() {
        K.SecretKey * K.PublicKey k1 = K.KeyGen();
        K.SecretKey * K.PublicKey k2 = K.KeyGen();
        sk = [k1[0], k2[0]];
        pk = [k1[1], k2[1]];
        return pk;
    }

    // Takes as input a sender index and receiver index
    K.Ciphertext? * K.SharedSecret? Chall(Int i, Int j) {
        if ((i != 1 && i != 2) || (j != 1 && j != 2)) { return [None, None]; }
        K.SharedSecret * K.Ciphertext result = K.AuthEncap(pk[j-1], sk[i-1]);
        //C[[pk[i-1], pk[j-1], result[1]]] = result[0];
        return result;
    }

    K.Ciphertext? * K.SharedSecret? AEncap(Int i, K.PublicKey pkR) {
        if (i != 1 && i != 2) { return [None, None]; }
        K.SharedSecret * K.Ciphertext result = K.AuthEncap(pkR, sk[i-1]);
        return result;
    }

    K.SharedSecret? ADecap(Int j, K.PublicKey pkS, K.Ciphertext c) {
        if (j != 1 && j != 2) { return None; }
        if ([pkS, pk[j-1], c] in C) { return None; }
        K.SharedSecret result = K.AuthDecap(c, sk[j-1], pkS);
        return result;
    }

    // KDF is modelled as a random oracle
    K.SharedSecret KDF(BitString ikm, BitString info) {
        K.SharedSecret k;
        if (!([ikm, info] in T)) {
            //T[[ikm, info]] <- K.SharedSecret;
            k <- K.SharedSecret;
        }
        //return T[[ikm, info]];
        return k;
    }
}

Game Right(AKEM K) {
    K.PublicKey * K.PublicKey pk;
    K.SecretKey * K.SecretKey sk;

    Map<K.PublicKey * K.PublicKey * K.Ciphertext, K.SharedSecret> C; // [pkS, pkR, context] -> AKEM shared secret

    K.PublicKey * K.PublicKey Initialize() {
        K.SecretKey * K.PublicKey k1 = K.KeyGen();
        K.SecretKey * K.PublicKey k2 = K.KeyGen();
        sk = [k1[0], k2[0]];
        pk = [k1[1], k2[1]];
        return pk;
    }

    // Takes as input a sender index and receiver index
    K.Ciphertext? * K.SharedSecret? Chall(Int i, Int j) {
        if ((i != 1 && i != 2) || (j != 1 && j != 2)) { return [None, None]; }
        K.SharedSecret * K.Ciphertext result = K.AuthEncap(pk[j-1], sk[i-1]);
        result[1] <- K.SharedSecret;
        //C[[pk[i], pk[j], result[1]]] = result[0];
        return result;
    }

    K.Ciphertext? * K.SharedSecret? AEncap(Int i, K.PublicKey pkR) {
        if (i != 1 && i != 2) { return [None, None]; }
        K.SharedSecret * K.Ciphertext result = K.AuthEncap(pkR, sk[i-1]);
        return result;
    }

    K.SharedSecret? ADecap(Int j, K.PublicKey pkS, K.Ciphertext c) {
        if (j != 1 && j != 2) { return None; }
        if ([pkS, pk[j-1], c] in C) { return None; }
        K.SharedSecret result = AuthDecap(c, sk[j-1], pkS);
        return result;
    }
}

export as OutsiderCCA;

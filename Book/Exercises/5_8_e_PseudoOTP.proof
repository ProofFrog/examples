import 'examples/Primitives/PRG.primitive';
import 'examples/Book/5/5_2_PseudoOTP.scheme';
import 'examples/Games/SymEnc/OneTimeUniformCiphertexts.game';
import 'examples/Schemes/SymEnc/OTP.scheme';

Reduction R1(PRG G, PRG_5_8_e H) compose Security(G) against OneTimeUniformCiphertexts(P).Adversary {
    BitString<H.lambda + H.stretch> CTXT(E.Message m) {
        return challenger.Query() + m;
    }
}

Reduction R2(PRG G, PRG_5_8_e H) compose OneTimeUniformCiphertexts(P) against OneTimeUniformCiphertexts(P).Adversary {
    BitString<H.lambda + H.stretch> Query() {
        BitString<3 * H.lambda> result = challenger.CTXT(G.evaluate(0b0));
        return result;
    }
}

proof:

let:
    Int lambda;
    PRG G = PRG(lambda, 2 * lambda);
    PseudoOTP P = PseudoOTP(lambda, 2 * lambda, G);
    OTP E = OTP(3 * lambda);

assume:
    Security(G);
    OneTimeUniformCiphertexts(E);

theorem:
    OneTimeUniformCiphertexts(P);

games:
    OneTimeUniformCiphertexts(H).Real against OneTimeUniformCiphertexts(P).Adversary;

    Security(G).Real compose R() against OneTimeUniformCiphertexts(P).Adversary;

    Security(G).Random compose R() against OneTimeUniformCiphertexts(P).Adversary;

    OneTimeUniformCiphertexts(H).Random against OneTimeUniformCiphertexts(P).Adversary;

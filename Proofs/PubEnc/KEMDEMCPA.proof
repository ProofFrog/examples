import 'examples/Primitives/KEM.primitive';
import 'examples/Primitives/PubKeyEnc.primitive';
import 'examples/Primitives/NonNullableSymEnc.primitive';
import 'examples/Schemes/PubEnc/KEMDEM.scheme';
import 'examples/Games/KEM/CPAKEM.game';
import 'examples/Games/SymEnc/OneTimeSecrecy.game';
import 'examples/Games/SymEnc/KeyUniformity.game';
import 'examples/Games/PubKeyEnc/CPA.game';

Reduction R1(SymEnc E, KEM K, KEMDEM KD) compose CPAKEM(K) against CPA(KD).Adversary {
    KD.Ciphertext Challenge(KD.Message mL, KD.Message mR) {
        K.SharedSecret * K.Ciphertext y = challenger.Challenge();
        K.SharedSecret k_sym = y[0];
        K.Ciphertext c_kem = y[1];
        E.Ciphertext c_sym = E.Enc(k_sym, mL);
        return [c_kem, c_sym];
    }
}

Reduction R2(SymEnc E, KEM K, KEMDEM KD) compose KeyUniformity(E) against CPA(KD).Adversary {
    K.PublicKey pk;
    K.SecretKey sk;

    K.PublicKey Initialize() {
        K.PublicKey * K.SecretKey k = K.KeyGen();
        pk = k[0];
        sk = k[1];
        return pk;
    }

    KD.Ciphertext Challenge(KD.Message mL, KD.Message mR) {
        K.SharedSecret * K.Ciphertext x = K.Encaps(pk);
        K.SharedSecret k_sym = challenger.Challenge();
        K.Ciphertext c_kem = x[1];
        E.Ciphertext c_sym = E.Enc(k_sym, mL);
        return [c_kem, c_sym];
    }
}

Reduction R3(SymEnc E, KEM K, KEMDEM KD) compose OneTimeSecrecy(E) against CPA(KD).Adversary {
    K.PublicKey pk;
    K.SecretKey sk;

    K.PublicKey Initialize() {
        K.PublicKey * K.SecretKey k = K.KeyGen();
        pk = k[0];
        sk = k[1];
        return pk;
    }

    KD.Ciphertext Challenge(KD.Message mL, KD.Message mR) {
        K.SharedSecret * K.Ciphertext x = K.Encaps(pk);
        K.Ciphertext c_kem = x[1];
        E.Ciphertext c_sym = challenger.Eavesdrop(mL, mR);
        return [c_kem, c_sym];
    }
}

Reduction R4(SymEnc E, KEM K, KEMDEM KD) compose KeyUniformity(E) against CPA(KD).Adversary {
    K.PublicKey pk;
    K.SecretKey sk;

    K.PublicKey Initialize() {
        K.PublicKey * K.SecretKey k = K.KeyGen();
        pk = k[0];
        sk = k[1];
        return pk;
    }

    KD.Ciphertext Challenge(KD.Message mL, KD.Message mR) {
        K.SharedSecret * K.Ciphertext x = K.Encaps(pk);
        K.SharedSecret k_sym = challenger.Challenge();
        K.Ciphertext c_kem = x[1];
        E.Ciphertext c_sym = E.Enc(k_sym, mR);
        return [c_kem, c_sym];
    }
}

Reduction R5(SymEnc E, KEM K, KEMDEM KD) compose CPAKEM(K) against CPA(KD).Adversary {
    KD.Ciphertext Challenge(KD.Message mL, KD.Message mR) {
        K.SharedSecret * K.Ciphertext y = challenger.Challenge();
        K.SharedSecret k_sym = y[0];
        K.Ciphertext c_kem = y[1];
        E.Ciphertext c_sym = E.Enc(k_sym, mR);
        return [c_kem, c_sym];
    }
}

proof:

let:
    Set SymMessageSpace;
    Set KEMSharedSecretSpace;
    Set SymCiphertextSpace;
    Set KEMCiphertextSpace;

    Set PubKeySpace;
    Set SecretKeySpace;

    SymEnc E = SymEnc(SymMessageSpace, SymCiphertextSpace, KEMSharedSecretSpace);
    KEM K = KEM(KEMSharedSecretSpace, KEMCiphertextSpace, PubKeySpace, SecretKeySpace);
    KEMDEM KD = KEMDEM(K, E);

assume:
    OneTimeSecrecy(E);
    KeyUniformity(E);
    CPAKEM(K);

theorem:
    CPA(KD);

games:
    CPA(KD).Left against CPA(KD).Adversary;
    CPAKEM(K).Left compose R1(E, K, KD) against CPA(KD).Adversary;
    CPAKEM(K).Right compose R1(E, K, KD) against CPA(KD).Adversary;
    KeyUniformity(E).Random compose R2(E, K, KD) against CPA(KD).Adversary;
    KeyUniformity(E).Real compose R2(E, K, KD) against CPA(KD).Adversary;
    OneTimeSecrecy(E).Left compose R3(E, K, KD) against CPA(KD).Adversary;
    OneTimeSecrecy(E).Right compose R3(E, K, KD) against CPA(KD).Adversary;
    KeyUniformity(E).Real compose R4(E, K, KD) against CPA(KD).Adversary;
    KeyUniformity(E).Random compose R4(E, K, KD) against CPA(KD).Adversary;
    CPAKEM(K).Right compose R5(E, K, KD) against CPA(KD).Adversary;
    CPAKEM(K).Left compose R5(E, K, KD) against CPA(KD).Adversary;
    CPA(KD).Right against CPA(KD).Adversary;
